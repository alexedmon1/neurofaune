#!/usr/bin/env python3
"""
Generate skull strip QC reports for all preprocessed data.

Produces standalone skull_strip_qc.html files in each modality's QC directory,
using the shared skull_strip_qc utilities (mosaic + triplanar figures + metrics).

Input file sources per modality:
  anat  - derivatives: desc-preproc_T2w (original), desc-brain_mask
  dwi   - work: b0.nii.gz (original), derivatives: desc-brain_mask
  func  - work: bold_ref_norm.nii.gz (original), derivatives: desc-brain_mask
  msme  - work: echo1.nii.gz (original), derivatives: desc-brain_mask

Usage:
    uv run python scripts/batch_skull_strip_qc.py /mnt/arborea/bpa-rat
    uv run python scripts/batch_skull_strip_qc.py /mnt/arborea/bpa-rat --modality anat
    uv run python scripts/batch_skull_strip_qc.py /mnt/arborea/bpa-rat --modality dwi --modality func
"""

import argparse
import json
import sys
import time
import traceback
from pathlib import Path

import nibabel as nib
import numpy as np

from neurofaune.preprocess.qc import get_subject_qc_dir
from neurofaune.preprocess.qc.skull_strip_qc import (
    calculate_skull_strip_metrics,
    plot_slicesdir_mosaic,
    plot_mask_edge_triplanar,
    skull_strip_html_section,
)

ALL_MODALITIES = ['anat', 'dwi', 'func', 'msme']


def find_sessions(study_root: Path, modality: str) -> list:
    """Find all subject/session pairs that have a brain mask for this modality."""
    derivatives = study_root / 'derivatives'
    sessions = []
    for sub_dir in sorted(derivatives.iterdir()):
        if not sub_dir.is_dir() or not sub_dir.name.startswith('sub-'):
            continue
        subject = sub_dir.name
        for ses_dir in sorted(sub_dir.iterdir()):
            if not ses_dir.is_dir() or not ses_dir.name.startswith('ses-'):
                continue
            session = ses_dir.name
            mod_dir = ses_dir / modality
            mask_file = mod_dir / f'{subject}_{session}_desc-brain_mask.nii.gz'
            if mask_file.exists():
                sessions.append((subject, session))
    return sessions


def get_original_file(study_root: Path, subject: str, session: str, modality: str) -> Path:
    """Return the pre-skull-strip file path for a given modality."""
    if modality == 'anat':
        return study_root / 'derivatives' / subject / session / 'anat' / f'{subject}_{session}_desc-preproc_T2w.nii.gz'
    elif modality == 'dwi':
        return study_root / 'work' / subject / session / 'dwi_preproc' / f'{subject}_{session}_b0.nii.gz'
    elif modality == 'func':
        return study_root / 'work' / subject / session / 'func_preproc' / 'skull_strip' / f'{subject}_{session}_bold_ref_norm.nii.gz'
    elif modality == 'msme':
        return study_root / 'work' / subject / session / 'msme_batch' / f'{subject}_{session}_echo1.nii.gz'
    else:
        raise ValueError(f"Unknown modality: {modality}")


def get_mask_file(study_root: Path, subject: str, session: str, modality: str) -> Path:
    """Return the brain mask path."""
    return study_root / 'derivatives' / subject / session / modality / f'{subject}_{session}_desc-brain_mask.nii.gz'


def create_standalone_html(subject, session, modality, metrics, skull_strip_section_html):
    """Wrap the skull strip HTML snippet in a full standalone page."""
    return f"""<!DOCTYPE html>
<html>
<head>
    <title>Skull Strip QC ({modality.upper()}) - {subject} {session}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }}
        .header {{ background-color: #2c3e50; color: white; padding: 20px; border-radius: 5px; }}
        .section {{ background-color: white; margin: 20px 0; padding: 20px; border-radius: 5px;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .metric {{ display: inline-block; margin: 10px 20px 10px 0; padding: 10px;
                   background-color: #fff; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }}
        .metric-label {{ font-weight: bold; color: #555; font-size: 0.9em; }}
        .metric-value {{ color: #000; font-size: 1.2em; margin-top: 5px; }}
        .good {{ color: #27ae60; font-weight: bold; }}
        .warning {{ color: #f39c12; font-weight: bold; }}
        img {{ max-width: 100%; height: auto; margin: 10px 0; border: 1px solid #ddd; border-radius: 5px; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>Skull Strip QC Report ({modality.upper()})</h1>
        <p>Subject: {subject} | Session: {session}</p>
    </div>

    {skull_strip_section_html}

    <hr>
    <p style="text-align: center; color: #888; font-size: 0.9em;">
        Generated by Neurofaune skull strip QC batch script
    </p>
</body>
</html>"""


def process_session(study_root, subject, session, modality):
    """Generate skull strip QC for one subject/session/modality."""
    original_file = get_original_file(study_root, subject, session, modality)
    mask_file = get_mask_file(study_root, subject, session, modality)

    if not original_file.exists():
        return None, f"original file missing: {original_file}"
    if not mask_file.exists():
        return None, f"mask file missing: {mask_file}"

    # Set up output directory
    qc_dir = get_subject_qc_dir(study_root, subject, session, modality)
    figures_dir = qc_dir / 'figures'
    figures_dir.mkdir(exist_ok=True)

    # Load data
    orig_img = nib.load(original_file)
    orig_data = orig_img.get_fdata()
    mask_data = nib.load(mask_file).get_fdata() > 0

    # Compute metrics
    metrics = calculate_skull_strip_metrics(
        orig_data,
        orig_data * mask_data,
        mask_data,
        voxel_sizes=orig_img.header.get_zooms()[:3],
    )

    # Generate figures
    figures = []
    figures.append(plot_slicesdir_mosaic(
        orig_data, mask_data, subject, session, modality, figures_dir
    ))
    figures.append(plot_mask_edge_triplanar(
        orig_data, mask_data, subject, session, modality, figures_dir
    ))

    # Generate HTML snippet
    section_html = skull_strip_html_section(metrics, figures)

    # Write standalone HTML report
    full_html = create_standalone_html(subject, session, modality, metrics, section_html)
    report_path = qc_dir / f'{subject}_{session}_skull_strip_qc.html'
    with open(report_path, 'w') as f:
        f.write(full_html)

    # Save metrics JSON
    metrics_path = qc_dir / f'{subject}_{session}_skull_strip_metrics.json'
    serializable = {k: (float(v) if isinstance(v, (np.floating, np.integer)) else v)
                    for k, v in metrics.items()}
    with open(metrics_path, 'w') as f:
        json.dump(serializable, f, indent=2)

    return report_path, None


def main():
    parser = argparse.ArgumentParser(description='Batch skull strip QC generation')
    parser.add_argument('study_root', type=Path, help='Study root directory')
    parser.add_argument('--modality', action='append', dest='modalities',
                        choices=ALL_MODALITIES,
                        help='Modality to process (can specify multiple; default: all)')
    args = parser.parse_args()

    study_root = args.study_root
    modalities = args.modalities or ALL_MODALITIES

    if not study_root.exists():
        print(f"Error: study root does not exist: {study_root}")
        sys.exit(1)

    print(f"Study root: {study_root}")
    print(f"Modalities: {', '.join(modalities)}")
    print()

    total_success = 0
    total_skipped = 0
    total_failed = 0
    start_time = time.time()

    for modality in modalities:
        sessions = find_sessions(study_root, modality)
        print(f"{'='*70}")
        print(f"  {modality.upper()}: {len(sessions)} sessions found")
        print(f"{'='*70}")

        mod_success = 0
        mod_skipped = 0
        mod_failed = 0

        for i, (subject, session) in enumerate(sessions):
            try:
                report, error = process_session(study_root, subject, session, modality)
                if error:
                    print(f"  [{i+1}/{len(sessions)}] SKIP {subject} {session}: {error}")
                    mod_skipped += 1
                else:
                    print(f"  [{i+1}/{len(sessions)}] OK   {subject} {session}")
                    mod_success += 1
            except Exception as e:
                print(f"  [{i+1}/{len(sessions)}] FAIL {subject} {session}: {e}")
                traceback.print_exc()
                mod_failed += 1

        total_success += mod_success
        total_skipped += mod_skipped
        total_failed += mod_failed
        print(f"  {modality.upper()} summary: {mod_success} OK, {mod_skipped} skipped, {mod_failed} failed\n")

    elapsed = time.time() - start_time
    print(f"{'='*70}")
    print(f"TOTAL: {total_success} OK, {total_skipped} skipped, {total_failed} failed")
    print(f"Elapsed: {elapsed/60:.1f} min")


if __name__ == '__main__':
    main()
